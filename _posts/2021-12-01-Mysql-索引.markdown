---
layout: post
title:  "Mysql-索引"
date:   2021-12-01 16:30 +0800
categories: mysql
typora-root-url: ./image
---

## **索引原理**

如果把业务数据比作为一本字典的话，那么索引就是这本字典的目录。如果我让你查一个字，在你不使用目录查的时候，那只能一页一页的翻，运气不好的话可能要翻到最后一页才能查到想要的字，这就是传说中的全表扫描。但是如果我们通过目录来查找，那么可以很快定位字所在页，进而查找到对应的字。

我们都知道在Mysql中索引的数据结构是**B+树**，那么我们就一步一步来看看，索引在磁盘中的B+树是怎么长成的。

### 数据页

Mysql数据库中的表实际在磁盘当中是通过一页页的数据页进行存储的。数据页是磁盘与内存交互的基本单位，Mysql的Innodb存储引擎，通过buffer pool与磁盘中的数据页进行交互，而不是直接操作磁盘中的数据页。数据页的结构如下图所示：

![mysql_索引——数据页结构](/../../image/mysql/mysql_索引——数据页结构.png)

同时相邻的数据页之间通过双向链表来维护数据页之间的相互引用。Mysql的InnoDB存储引擎数据页大小是16KB。Mysql的Innodb存储引擎通过页号来唯一定位一个数据页，因此每个数据页都有自己的页号。通过上图可知，每个数据页都有都有对应的**Page Header**，在Page Header中保存了当前数据页的页号，以及其下一页的页号和上一页的页号。

相邻的数据之间通过指针进行互相引用，指针标注数据页的页号，每个数据页中存储了连续的一段数据，每个数据行中的记录头部存有下一行记录真实数据的地址偏移量，简单理解为拥有指针指向下一行数据的地址。因此在数据页的内部，实际是关于数据行的单向链表。这个单向链表是关于主键id的，从小到大进行排列。

![mysql_索引_数据页](/../../image/mysql/mysql_索引_数据页.png)

从上述的数据页结构可知，每次进行数据插入时User Records区域就会变大，相应的的User Record区域就会减少。当User Record区域消耗完之后，就会发生页分裂，形成新的数据页。这里需要注意的是，如果我们使用的是Mysql中的自增主键，那么可以保证按照id的增长顺序进行数据行排列，但是如果主键是我们自己设置的并不是自增长的，那么有可能出现后面插入的数据的主键值小于前面数据的主键值，那么在进行页分裂的时候，Mysql会按照主键大小重新进行排列。此处不知道大家有没有疑问，为什么一定要按照主键大小进行排列呢？实际上和后续的数据查询有关系，数据页中的数据按照主键顺序进行排列是索引可以正常运行的基础。大致的过程如下图所示：

![mysql_索引_数据页分裂](/../../image/mysql/mysql_索引_数据页分裂.png)

### 页目录

每个数据页都有自己的页目录上面页结构中的Page Directory，这个页目录的作用实际上就是用来进行数据行定位的。数据页中的数据实际上是按组分配的，页目录中的不同的槽位，其实是对应了数据页中的不同的分组，查询数据时，通过id找到对应的槽，再根据对应的槽来知道对应在数据页中的数据行分组，遍历数据行分组中的数据直到找到对应的数据。

![mysql_索引_页目录](/../../image/mysql/mysql_索引_页目录.png)

## **索引原理分析**

### 索引基础

Mysql通过主键目录实际就是传说中的主键索引，实现数据的查询优化。在主键目录中包含了两个重要元素，一个是数据页中最小的主键，另一个是当前数据页的页号。这样可以通过这个主键目录方面的进行数据查询。

举个栗子，如果此时想要查询主键id=5的数据，那么首先在主键目录中进行查找。此时发现主键id=5大于主键id=1，但是又小于id=8，那么就可以确定实际上数据实际是在页号为1的数据页中的。

当然在实际在Mysql中会有很多的数据页，因此对应的主键索引也会很多，那么此时就需要通过二分查找的方式进行数据页定位，再查找到对应的数据。

![mysql_索引_数据页索引](/../../image/mysql/mysql_索引_数据页索引.png)

### 索引页

按照上述的主键目录，那么就需要存储大量的主键与数据页号。即便是进行二分查找，其数据查询效率也是比较低的。

Mysql实际是将索引数据存储在索引页中的，当数据量比较大时候，对应的索引也会比较多，因此通过专门的索引页来存储索引数据。另外在这些索引页的上层又通过主键与索引页号来继续进行索引页的查询定位，因此我们得到如下的结构。其中的id号指的是对应最小的id号。

![mysql_索引_索引页索引](/../../image/mysql/mysql_索引_索引页索引.png)

如果索引页中的数据越来越多，索引页同样会进行页分裂。这样索引页也就形成了不同的层级，索引页层、索引页、数据页这三个页数据就形成了我们说的B+树。下图就是索引的B+树结构，通过它完成数据查询效率远高于全表扫描。B+的叶子节点才会存储数据，下图是一种主键索引，也叫聚簇索引。其实我们可以看出来，它的根本思想就是分而治之的思想。

![mysql_索引_B+树](/../../image/mysql/mysql_索引_B+树.png)

数据查询在B+树中的查询过程：举个栗子，如当前需要查询id为3的数据，那么将在索引页中判断应该走索引页为3的索引页。那么在索引页为3中继续判断id=1应该走索引页为1的索引页，在索引页中判断应该页号为1的数据页，在此数据页中遍历最终查询到对应的数据。

![mysql_索引_B+树查询](/../../image/mysql/mysql_索引_B+树查询.png)

以上通过索引页与数据页组成的B+树就是聚簇索引，当然我们也可以通过其他字段来建立普通索引。知识普通索引会的叶子节点存储的是对应的主键id，而不是具体的数据，索引会存在回表的问题，即查询到对应的id之后，还需要根据id继续到聚簇索引中查询具体的数据，通过这样的操作才能查询到select *的所有数据。当然我们可以通过覆盖索引的方式避免这样的查询浪费。