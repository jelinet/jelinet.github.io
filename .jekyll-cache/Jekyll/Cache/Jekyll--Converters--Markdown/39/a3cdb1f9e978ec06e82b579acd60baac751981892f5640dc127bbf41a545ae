I"<h2 id="rdb-文件的创建与载入">RDB 文件的创建与载入</h2>
<p>一个概念：服务器中非空数据库以及数据库中的键值对 称为 <strong>数据库状态</strong></p>
<h3 id="创建">创建</h3>
<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">def</span> <span class="n">SAVE</span><span class="p">()</span><span class="o">:</span>

<span class="cp"># 创建RDB文件
</span><span class="n">rdbSave</span><span class="p">()</span>



<span class="n">def</span> <span class="n">BGSAVE</span><span class="p">()</span><span class="o">:</span>
   
	<span class="cp"># 创建子进程
</span>   <span class="n">pid</span> <span class="o">=</span> <span class="n">fork</span><span class="p">()</span>
    			
	<span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="o">:</span>
			
		<span class="cp"># 子进程负责创建RDB文件
</span>		<span class="n">rdbSave</span><span class="p">()</span>
		
		<span class="cp"># 完成之后向父进程发送信号
</span>		<span class="n">signal_parent</span><span class="p">()</span>
	<span class="k">else</span> <span class="k">if</span> <span class="n">pid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">:</span>
	
		<span class="cp"># 父进程继续处理命令请求，并通过轮询等待子进程的信
</span>		<span class="n">handle_request_and_wait_signal</span><span class="p">()</span>
		
	<span class="k">else</span><span class="o">:</span>
	
		<span class="cp"># 处理出错情况
</span>		<span class="n">handle_fork_error</span><span class="p">()</span>
</code></pre></div></div>
<ul>
  <li>SAVE命令会阻塞Redis服务器进程，直到RDB文件创建完毕为止，在服务器进程阻塞期间，服务器不能处理任何命令请求</li>
  <li>BGSAVE命令会派生出一个子进程，然后由子进程负责创建RDB文件，服务器进程（父进程）继续处理命令请求</li>
  <li>BGSAVE命令执行时的服务器状态
    <ol>
      <li>BGSAVE执行期间，客户端发送的SAVE、BGSAVE 会被服务器拒绝，避免rdbSave()重复调用</li>
      <li>BGSAVE正在执行，客户端发送的BGREWRITEAOF命令会被延迟到BGSAVE命令执行完毕之后执行；BGREWRITEAOF正在执行，客户端发送的BGSAVE命令会被服务器拒绝。原因是性能考虑，这两个操作并发出两个子线程，并且都进行了大量磁盘写入操作</li>
    </ol>
  </li>
</ul>

<h3 id="载入">载入</h3>
<p>服务器载入RDB文件会一直处于阻塞状态</p>

<h2 id="自动间歇性保存">自动间歇性保存</h2>
<ol>
  <li>
    <p>当服务器启动的时候，客户端可以设置服务器的save选项，每隔一段时间执行一次BGSAVE（serverCron()）;</p>

    <p>~~~c
 /**</p>
    <ul>
      <li>客户端没有配置-&gt;默认的配置</li>
    </ul>
  </li>
</ol>

  	  * 任意条件满足即合 
  	  */
  	save 900 1    //900秒内，对数据库至少一次修改
  	save 300 10
  	save 60 10000
  	~~~
<ol>
  <li>设置保存条件
    <ul>
      <li>
        <p>结构</p>

        <p>~~~c
  struct redisServer {</p>
      </li>
    </ul>

  		// …

 		// 记录了保存条件的数组
 		struct saveparam *saveparams;

 		// 修改计数器
 		long long dirty;

 		// 上一次执行保存的时间
  		time_t lastsave;

  		// …
  	};

  	struct saveparam {
  		// 秒数  <br />
  		time_t seconds;
  		// 修改数
  		int changes;
  	};

  	~~~<br />

    <ul>
      <li>根据配置来设置redisServer中的saveparams</li>
      <li>dirty计数器：记录上一次SAVE或BGSAVE后，数据库状态进行了多少次修改<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup></li>
      <li>lastsave是UNIX时间戳，上一次SAVE或BGSAVE时间</li>
    </ul>
  </li>
  <li>检查保存条件是否满足
    <ul>
      <li>
        <p>伪代码</p>

        <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="n">def</span> <span class="n">serverCron</span><span class="p">()</span><span class="o">:</span>    
      <span class="cp"># ...
</span>			  
      <span class="cp"># 遍历所有保存条件    
</span>      <span class="k">for</span> <span class="n">saveparam</span> <span class="n">in</span> <span class="n">server</span><span class="p">.</span><span class="n">saveparams</span><span class="o">:</span>
			
          <span class="cp"># 计算距离上次执行保存操作有多少秒        
</span>          <span class="n">save_interval</span> <span class="o">=</span> <span class="n">unixtime_now</span><span class="p">()</span><span class="o">-</span><span class="n">server</span><span class="p">.</span><span class="n">lastsave</span>
		        
          <span class="cp"># 如果数据库状态的修改次数超过条件所设置的次数        
</span>          <span class="cp"># 并且距离上次保存的时间超过条件所设置的时间        
</span>          <span class="cp"># 那么执行保存操作
</span>          <span class="k">if</span>  <span class="n">server</span><span class="p">.</span><span class="n">dirty</span> <span class="o">&gt;=</span> <span class="n">saveparam</span><span class="p">.</span><span class="n">changes</span> 
          	<span class="n">and</span> <span class="n">save_interval</span> <span class="o">&gt;</span> <span class="n">saveparam</span><span class="p">.</span><span class="n">seconds</span><span class="o">:</span>
		        	
              <span class="n">BGSAVE</span><span class="p">()</span>
		            
      <span class="cp"># ...
</span></code></pre></div>        </div>
      </li>
      <li>服务器周期性函数serverCorn默认每100mm执行一次，其中一项工作就是检查BGSAVE命令的条件是否满足</li>
      <li>任意saveparam满足，就执行BGSAVE</li>
    </ul>
  </li>
</ol>

<h2 id="rdb文件结构">RDB文件结构</h2>
<p>| REDIS | db_version | databases | EOF |check_sum</p>
<h2 id="分析rdb文件">分析RDB文件</h2>

<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:1" role="doc-endnote">
      <p>如果向一个集合键增加三个新元素,dirty会加3 <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>
:ET